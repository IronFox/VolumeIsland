// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel EmitVertex


struct Vertex
{
    float3 position;
    float3 normal;
};
RWStructuredBuffer<Vertex> VertexOut;
AppendStructuredBuffer<uint> CellOut;
Texture3D<float> Volume;
float3 Origin;
float VoxelSize;
uint SizeInVoxels;
RWTexture3D<uint> IndexOutMapX;
RWTexture3D<uint> IndexOutMapY;
RWTexture3D<uint> IndexOutMapZ;


AppendStructuredBuffer<float> DebugOut;

//AppendStructuredBuffer<uint4> DebugIndexOutY;
//AppendStructuredBuffer<uint4> DebugIndexOutZ;

//shared float sharedDensity[THREADS_PER_GROUP_X + 2][THREADS_PER_GROUP_Y + 2];


static const float iso = 0.5;

groupshared float loaded[9][9][9];

[numthreads(8,8,8)]
void EmitVertex(uint3 id : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    //id = 7,6,15
    //localId = 7,6,7
    //bad (local) = 8,7,8
    if (all(id < SizeInVoxels)) //true
    {
        loaded[localId.x][localId.y][localId.z] = Volume[id];
        if (localId.x == 7) //true
        {
            loaded[8][localId.y][localId.z] = Volume[id + uint3(1, 0, 0)];
        
            if (localId.y == 7)//false (1) / true (2)
            {
                loaded[8][8][localId.z] = Volume[id + uint3(1, 1, 0)];

                if (localId.z == 7)
                {
                    loaded[8][8][8] = Volume[id + uint3(1, 1, 1)];
                    loaded[8][localId.y][8] = Volume[id + uint3(1, 0, 1)];
                }
            }
            else if (localId.z == 7)    //true
            {
                loaded[8][localId.y][8] = Volume[id + uint3(1, 0, 1)];
            }
        }
        if (localId.y == 7)//false (1) / true (2)
        {
            loaded[localId.x][8][localId.z] = Volume[id + uint3(0, 1, 0)];

            if (localId.z == 7)
            {
                loaded[localId.x][8][8] = Volume[id + uint3(0, 1, 1)];
                loaded[localId.x][localId.y][8] = Volume[id + uint3(0, 0, 1)];
            }
        }
        if (localId.z == 7)//true
        {
            loaded[localId.x][localId.y][8] = Volume[id + uint3(0, 0, 1)];
        }
    }
    
    AllMemoryBarrierWithGroupSync();
    
    
    if (any(id >= SizeInVoxels))
        return;
    

    

    //if (any(id + 1 == SizeInVoxels))
    //    return;

    uint3 outer = localId + 1;



    float d = loaded[localId.x][localId.y][localId.z];
    float dx = loaded[outer.x][localId.y][localId.z];   // <- 1
    float dy = loaded[localId.x][outer.y][localId.z];   // <- 2
    float dz = loaded[localId.x][localId.y][outer.z];
    
    float dxy = loaded[outer.x][outer.y][localId.z];
    float dyz = loaded[localId.x][outer.y][outer.z];
    float dxz = loaded[outer.x][localId.y][outer.z];
    float dxyz = loaded[outer.x][outer.y][outer.z];

    bool4 d0 = float4(d, dx, dy, dz) >= iso;
    bool4 d1 = float4(dxy, dyz, dxz, dxyz) >= iso;
    
    

    //bool debugEmit = all(id == uint3(0, 0, 0));

    //if (!debugEmit)
    //    return;

    uint cubeindex = 0;
    if (all(id < SizeInVoxels-1))
        if ((any(d0) || any(d1)) && !(all(d0) && all(d1)))
    {
        float value0 = d;
        float value1 = dx; // px    <- 1
        float value2 = dy; // py    <- 2
        float value3 = dxy; // pxy
        float value4 = dz; // pz
        float value5 = dxz; // pxz
        float value6 = dyz; // pyz
        float value7 = dxyz; // pxyz

        if (value0 < iso)
            cubeindex |= 1<<0;
        if (value1 < iso)
            cubeindex |= 1<<1;//
        if (value2 < iso)
            cubeindex |= 1<<3;
        if (value3 < iso)
            cubeindex |= 1<<2;
        if (value4 < iso)
            cubeindex |= 1<<4;
        if (value5 < iso)
            cubeindex |= 1<<5;
        if (value6 < iso)
            cubeindex |= 1<<7;
        if (value7 < iso)
            cubeindex |= 1<<6;

        uint4 u4 = uint4(id, cubeindex);
            
        CellOut.Append((u4.x) | (u4.y << 8) | (u4.z << 16) | (u4.w << 24));
    }

    float3 neighbors = float3(dx, dy, dz);
    float3 delta = neighbors - d;
    float3 x = (iso - d) / delta;
    bool3 edge = x >= 0 && x < 1;
    float3 p0 = Origin + VoxelSize * id;

    //if (any(edge))
    //{
    //    uint i = VertexOut.IncrementCounter();
    //    Vertex v;
    //    v.position = p0;
    //    v.position.x += VoxelSize * x.x;
    //    v.normal = normalize(-delta);
    //    VertexOut[i] = v;
    //}
    
    if (edge.x)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapX[id] = i;
        Vertex v;
        v.position = p0;
        v.position.x += VoxelSize * x.x;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
        //DebugIndexOutX.Append(int4(id, i));
    }
    else
        IndexOutMapX[id] = 0xffffffff;


    if (edge.y)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapY[id] = i;
        Vertex v;
        v.position = p0;
        v.position.y += VoxelSize * x.y;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
        //DebugIndexOutY.Append(int4(id, i));
    }
    else
        IndexOutMapY[id] = 0xffffffff;
    if (edge.z)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapZ[id] = i;
        Vertex v;
        v.position = p0;
        v.position.z += VoxelSize * x.z;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
        //DebugIndexOutZ.Append(int4(id,i));
    }
    else
        IndexOutMapZ[id] = 0xffffffff;
}

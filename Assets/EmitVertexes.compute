// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel EmitVertex


struct Vertex
{
    float3 position;
    float3 normal;
};
RWStructuredBuffer<Vertex> VertexOut;
AppendStructuredBuffer<uint4> CellOut;
Texture3D<float2> Volume;
float3 Origin;
float VoxelSize;
uint SizeInVoxels;
RWTexture3D<uint> IndexOutMapX;
RWTexture3D<uint> IndexOutMapY;
RWTexture3D<uint> IndexOutMapZ;

//shared float sharedDensity[THREADS_PER_GROUP_X + 2][THREADS_PER_GROUP_Y + 2];


static const float iso = 0.5;

groupshared float loaded[9][9][9];

[numthreads(8,8,8)]
void EmitVertex(uint3 id : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    if (all(id < SizeInVoxels))
    {
        loaded[localId.x][localId.y][localId.z] = Volume[id].x;
        if (localId.x == 7)
        {
            loaded[8][localId.y][localId.z] = Volume[id + uint3(1, 0, 0)].x;
        
            if (localId.y == 7)
            {
                loaded[8][8][localId.z] = Volume[id + uint3(1, 1, 0)].x;

                if (localId.z == 7)
                {
                    loaded[8][8][8] = Volume[id + uint3(1, 1, 1)].x;
                }
            }
        }
        if (localId.y == 7)
        {
            loaded[localId.x][8][localId.z] = Volume[id + uint3(0, 1, 0)].x;

            if (localId.z == 7)
            {
                loaded[localId.x][8][8] = Volume[id + uint3(0, 1, 1)].x;
            }
        }
        if (localId.z == 7)
        {
            loaded[localId.x][localId.y][8] = Volume[id + uint3(0, 0, 1)].x;
        }
    }
    
    AllMemoryBarrierWithGroupSync();
    
    
    if (any(id >= SizeInVoxels))
        return;
    
    

    //if (any(id + 1 == SizeInVoxels))
    //    return;

    uint3 outer = min(localId + 1, SizeInVoxels - 1);



    float d = loaded[localId.x][localId.y][localId.z];
    float dx = loaded[outer.x][localId.y][localId.z];
    float dy = loaded[localId.x][outer.y][localId.z];
    float dz = loaded[localId.x][localId.y][outer.z];
    
    float dxy = loaded[outer.x][outer.y][localId.z];
    float dyz = loaded[localId.x][outer.y][outer.z];
    float dxz = loaded[outer.x][localId.y][outer.z];
    float dxyz = loaded[outer.x][outer.y][outer.z];

    bool4 d0 = float4(d, dx, dy, dz) >= iso;
    bool4 d1 = float4(dxy, dyz, dxz, dxyz) >= iso;

    if ((any(d0) || any(d1)) && !(all(d0) && all(d1)))
    {
        float value0 = d;
        float value1 = dx; // px
        float value2 = dy; // py
        float value3 = dxy; // pxy
        float value4 = dz; // pz
        float value5 = dxz; // pxz
        float value6 = dyz; // pyz
        float value7 = dxyz; // pxyz

        uint cubeindex = 0;
        if (value0 < iso)
            cubeindex |= 1;
        if (value1 < iso)
            cubeindex |= 2;
        if (value2 < iso)
            cubeindex |= 8;
        if (value3 < iso)
            cubeindex |= 4;
        if (value4 < iso)
            cubeindex |= 16;
        if (value5 < iso)
            cubeindex |= 32;
        if (value6 < iso)
            cubeindex |= 128;
        if (value7 < iso)
            cubeindex |= 64;

        if (all(id == uint3(1, 1, 0)))
            CellOut.Append(uint4(id, cubeindex));
    }

    float3 neighbors = float3(dx, dy, dz);
    float3 delta = neighbors - d;
    float3 x = (iso - d) / delta;
    bool3 edge = x >= 0 && x < 1;
    float3 p0 = Origin + VoxelSize * id;

    //if (any(edge))
    //{
    //    uint i = VertexOut.IncrementCounter();
    //    Vertex v;
    //    v.position = p0;
    //    v.position.x += VoxelSize * x.x;
    //    v.normal = normalize(-delta);
    //    VertexOut[i] = v;
    //}

    if (edge.x)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapX[id] = i;
        Vertex v;
        v.position = p0;
        v.position.x += VoxelSize * x.x;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
    }
    if (edge.y)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapY[id] = i;
        Vertex v;
        v.position = p0;
        v.position.y += VoxelSize * x.y;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
    }
    if (edge.z)
    {
        uint i = VertexOut.IncrementCounter();
        IndexOutMapZ[id] = i;
        Vertex v;
        v.position = p0;
        v.position.z += VoxelSize * x.z;
        v.normal = normalize(-delta);
        VertexOut[i] = v;
    }
}
